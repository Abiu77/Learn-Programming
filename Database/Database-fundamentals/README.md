# Fundamentos de Bases de Datos
Mi resumen del libro de Ramez Elmasri y Shamkant B. Navathe
> Quinta Edición
### [Capítulo 1 - Introducción](#introducción)
- [**1.1** Aplicaiones de los sistemas de bases de datos](#11-aplicaciones-de-los-sistemas-de-bases-de-datos)
- [**1.2** Propósito de los sistemas de bases de datos](#12-propósito-de-los-sistemas-de-bases-de-datos)
- [**1.3** Visión de los datos](#visión-de-los-datos)
- [**1.4** Lenguajes de bases de datos](#7)
- [**1.5** Bases de datos relacionales](#9)
- [**1.6** Diseño de bases de datos](#11)
- [**1.7** Bases de datos basadas en objetos y semiestructuradas](#15)
- [**1.8** Almacenamiento de datos y consultas](#16)
- [**1.9** Gestión de transacciones](#17)
- [**1.10** Minería y análisis de datos](#18)
- [**1.11** Arquitectura de las bases de datos](#19)
- [**1.12** Usuarios y administradores de bases de datos](#21)
- [**1.13** Historia de los sistemas de bases de datos](#22)
- [**1.14** Resumen](#24)
  - [Ejercicios](#25)
  - [Notas bibliográficas](#26)
## Parte 1: Bases de datos relacionales
### Capítulo 2 - El modelo relacional
- [**2.1** La estructura de las bases de datos relacionales](#29)
- [**2.2** Operaciones fundamentales del álgebra relacional](#36)
- [**2.3** Otras operaciones del álgebra relacional](#44)
- [**2.4** Operaciones del álgebra relacional extendida](#48)
- [**2.5** Valores nulos](#53)
- [**2.6** Modificación de la base de datos](#54)
- [**2.7** Resumen](#56)
  - [Ejercicios](#57)
  - [Notas bibliográficas](#59)
### Capítulo 3 - SQL
- [**3.1** Introducción](#61)
- [**3.2** Definición de datos](#62)
- [**3.3** Estructura básica de los consultas SQL](#65)
- [**3.4** Operaciones sobre conjuntos](#71)
- [**3.5** Funciones de agregación](#73)
- [**3.6** Valores nulos](#75)
- [**3.7** Subconsultas anidadas](#76)
- [**3.8** Consultas complejas](#80)
- [**3.9** Vistas](#81)
- [**3.10** Modificación de la base de datos](#84)
- [**3.11** Reunión de relaciones**](#90)
- [**3.12** Resumen](#94)
  - [Ejercicios](#95)
  - [Notas bibliográficas](#98)
### Capítulo 4 - SQL avanzado
- [**4.1** Tipos de datos y esquemas](#101)
- [**4.2** Restricciones de integridad](#105)
- [**4.3** Autorización](#111)
- [**4.4** SQL incorporado](#112)
- [**4.5** SQL dinámico](#114)
- [**4.6** Funciones y procedimientos**](#121)
- [**4.7** Consultas recursivas**](#126)
- [**4.8** Características avanzadas de SQL**](#129)
- [**4.9** Resumen](#132)
  - [Ejercicios](#133)
  - [Notas bibliográficas](#135)
### Capítulo 5 - Otros lenguajes relacionales
- [**5.1** El cálculo relacional de tuplas](#137)
- [**5.2** El cálculo relacional de dominios](#141)
- [**5.3** Query-by-Example](#144)
- [**5.4** Datalog](#151)
- [**5.5** Resumen](#162)
  - [Ejercicios](#163)
  - [Notas bibliográficas](#165)
## Parte 2: Diseño de bases de datos
### Capítulo 6 - Diseño de bases de datos y el modelo E-R
- [**6.1** Visión general del proceso de diseño](#169)
- [**6.2** El modelo entidad-relación](#171)
- [**6.3** Restricciones](#176)
- [**6.4** Diagramas entidad-relación](#180)
- [**6.5** Aspectos del diseño entidad-relación](#184)
- [**6.6** Conjuntos de entidades débiles](#189)
- [**6.7** Características del modelo E-R extendido](#190)
- [**6.8** Diseño de una base de datos para un banco](#197)
- [**6.9** Reducción a esquemas relacionales](#200)
- [**6.10** Otros aspectos del diseño de bases de datos](#207)
- [**6.11** El lenguaje de modelado unificado UML∗∗](#210)
- [**6.12** Resumen](#212)
  - [Ejercicios](#213)
  - [Notas bibliográficas](#217)
### Capítulo 7 - Diseño de bases de datos relacionales
- [**7.1** Características de los buenos diseños relacionales](#219)
- [**7.2** Dominios atómicos y la primera forma normal](#223)
- [**7.3** Descomposición mediante dependencias funcionales](#224)
- [**7.4** Teoría de las dependencias funcionales](#231)
- [**7.5** Algoritmo de descomposición](#239)
- [**7.6** Descomposición mediante dependencias multivaloradas](#244)
- [**7.7** Más formas normales](#248)
- [**7.8** Proceso de diseño de las base de datos](#248)
- [**7.9** Modelado de datos temporales](#251)
- [**7.10** Resumen](#253)
  - [Ejercicios](#254)
  - [Notas bibliográficas](#257)
### Capítulo 8 - Diseño y desarrollo de aplicaciones
- [**8.1** Interfaces de usuario y herramientas](#259)
- [**8.2** Interfaces Web para bases de datos](#262)
- [**8.3** Fundamentos de Web](#263)
- [**8.4** Servlets y JSP](#267)
- [**8.5** Creación de aplicaciones Web de gran tamaño](#271)
- [**8.6** Disparadores](#273)
- [**8.7** Autorización en SQL](#278)
- [**8.8** Seguridad de las aplicaciones](#285)
- [**8.9** Resumen](#291)
  - [Ejercicios](#293)
  - [Notas bibliográficas](#297)
## Parte 3: Bases de datos orientadas a objetos y XML
### Capítulo 9 - Bases de datos basadas en objetos
- [**9.1** Visión general](#301)
- [**9.2** Tipos de datos complejos](#302)
- [**9.3** Tipos estructurados y herencia en SQL](#303)
- [**9.4** Herencia de tablas](#308)
- [**9.5** Tipos array y multiconjunto en SQL](#309)
- [**9.6** Identidad de los objetos y tipos de referencia en SQL](#313)
- [**9.7** Implementación de las características O-R](#315)
- [**9.8** Lenguajes de programación persistentes](#316)
- [**9.9** Sistemas orientados a objetos y sistemas relacionales orientados a objetos](#322)
- [**9.10** Resumen](#323)
  - [Ejercicios](#324)
  - [Notas bibliográficas](#327)
### Capítulo 10 - XML
- [**10.1** Motivación](#329)
- [**10.2** Estructura de los datos XML](#332)
- [**10.3** Esquema de los documentos XML](#335)
- [**10.4** Consulta y transformación](#340)
- [**10.5** La interfaz de programación de aplicaciones de XML](#349)
- [**10.6** Almacenamiento de datos XML](#350)
- [**10.7** Aplicaciones XML](#354)
- [**10.8** Resumen](#358)
  - [Ejercicios](#360)
  - [Notas bibliográficas](#362)
## Parte 4: Almacenamiento de datos y consultas
### Capítulo 11 - Almacenamiento y estructuras de archivos
- [**11.1** Visión general de los medios físicos de almacenamiento](#367)
- [**11.2** Discos magnéticos](#370)
- [**11.3** RAID](#375)
- [**11.4** Almacenamiento terciario](#382)
- [**11.5** Acceso al almacenamiento](#383)
- [**11.6** Organización de los archivos](#386)
- [**11.7** Organización de los registros en archivos](#390)
- [**11.8** Almacenamiento con diccionarios de datos](#393)
- [**11.9** Resumen](#395)
  - [Ejercicios](#396)
  - [Notas bibliográficas](#398)
### Capítulo 12 - Indexación y asociación
- [**12.1** Conceptos básicos](#401)
- [**12.2** Índices ordenados](#402)
- [**12.3** Archivos de índices de árbol B+](#408)
- [**12.4** Archivos de índices de árbol B](#417)
- [**12.5** Accesos bajo varias claves](#418)
- [**12.6** Asociación estática](#421)
- [**12.7** Asociación dinámica](#426)
- [**12.8** Comparación de la indexación ordenada y la asociación](#431)
- [**12.9** Índices de mapas de bits](#432)
- [**12.10** Definición de índices en SQL](#435)
- [**12.11** Resumen](#436)
  - [Ejercicios](#438)
  - [Notas bibliográficas](#440)
### Capítulo 13 - Procesamiento de consultas
- [**13.1** Visión general](#443)
- [**13.2** Medidas del coste de una consulta](#445)
- [**13.3** Operación selección](#446)
- [**13.4** Ordenación](#450)
- [**13.5** Operación reunión](#452)
- [**13.6** Otras operaciones](#463)
- [**13.7** Evaluación de expresiones](#466)
- [**13.8** Resumen](#470)
  - [Ejercicios](#472)
  - [Notas bibliográficas](#473)
### Capítulo 14 - Optimización de consultas
- [**14.1** Visión general](#475)
- [**14.2** Transformación de expresiones relacionales](#476)
- [**14.3** Estimación de las estadísticas de los resultados de las expresiones](#482)
- [**14.4** Elección de los planes de evaluación](#487)
- [**14.5** Vistas materializadas∗∗](#494)
- [**14.6** Resumen](#498)
  - [Ejercicios](#500)
  - [Notas bibliográficas](#502)
## Parte 5: Gestión de transacciones
### Capítulo 15 - Transacciones
- [**15.1** Concepto de transacción](#507)
- [**15.2** Estados de una transacción](#510)
- [**15.3** Implementación de la atomicidad y la durabilidad](#512)
- [**15.4** Ejecuciones concurrentes](#513)
- [**15.5** Secuencialidad](#516)
- [**15.6** Recuperabilidad](#520)
- [**15.7** Implementación del aislamiento](#522)
- [**15.8** Comprobación de la secuencialidad](#522)
- [**15.9** Resumen](#523)
  - [Ejercicios](#525)
  - [Notas bibliográficas](#527)
### Capítulo 16 - Control de concurrencia
- [**16.1** Protocolos basados en el bloqueo](#529)
- [**16.2** Protocolos basados en marcas temporales](#539)
- [**16.3** Protocolos basados en validación](#542)
- [**16.4** Granularidad múltiple](#544)
- [**16.5** Esquemas multiversión](#546)
- [**16.6** Tratamiento de interbloqueos](#548)
- [**16.7** Operaciones para insertar y borrar](#553)
- [**16.8** Niveles débiles de consistencia](#555)
- [**16.9** Concurrencia en los índices∗∗](#557)
- [**16.10** Resumen](#560)
  - [Ejercicios](#562)
  - [Notas bibliográficas](#566)
### Capítulo 17 - Sistema de recuperación
- [**17.1** Clasificación de los fallos](#567)
- [**17.2** Estructura del almacenamiento](#568)
- [**17.3** Recuperación y atomicidad](#571)
- [**17.4** Recuperación basada en el registro histórico](#572)
- [**17.5** Transacciones concurrentes y recuperación](#579)
- [**17.6** Gestión de la memoria intermedia](#581)
- [**17.7** Fallo con pérdida de almacenamiento no volátil](#584)
- [**17.8** Técnicas avanzadas de recuperación∗∗](#585)
- [**17.9** Sistemas remotos de copias de seguridad](#591)
- [**17.10** Resumen](#593)
  - [Ejercicios](#596)
  - [Notas bibliográficas](#597)
## Parte 6: Minería de datos y recuperción de información
### Capítulo 18 - Análisis y minería de datos
- [**18.1** Sistemas de ayuda a la toma de decisiones](#601)
- [**18.2** Análisis de datos y OLAP](#602)
- [**18.3** Almacenes de datos](#612)
- [**18.4** Minería de datos](#615)
- [**18.5** Resumen](#625)
  - [Ejercicios](#627)
  - [Notas bibliográficas](#628)
### Capítulo 19 - Recuperación de información
- [**19.1** Visión general](#631)
- [**19.2** Clasificación por relevancia según los términos](#632)
- [**19.3** Relevancia según los hipervínculos](#635)
- [**19.4** Sinónimos, homónimos y ontologías](#638)
- [**19.5** Creación de índices de documentos](#639)
- [**19.6** Medida de la efectividad de la recuperación](#640)
- [**19.7** Motores de búsqueda en Web](#641)
- [**19.8** Recuperación de información y datos estructurados](#642)
- [**19.9** Directorios](#643)
- [**19.10** Resumen](#645)
   - [Ejercicios](#646)
   - [Notas bibliográficas](#647)
## Parte 7: Arquitectura de sistemas
### Capítulo 20 - Arquitecturas de los sistemas de bases de datos
- [**20.1** Arquitecturas centralizadas y cliente–servidor](#651)
- [**20.2** Arquitecturas de sistemas servidores](#653)
- [**20.3** Sistemas paralelos](#657)
- [**20.4** Sistemas distribuidos](#663)
- [**20.5** Tipos de redes](#666)
- [**20.6** Resumen](#668)
  - [Ejercicios](#669)
  - [Notas bibliográficas](#671)
### Capítulo 21 - Bases de datos paralelas
- [**21.1** Introducción](#673)
- [**21.2** Paralelismo de E/S](#674)
- [**21.3** Paralelismo entre consultas](#677)
- [**21.4** Paralelismo en consultas](#678)
- [**21.5** Paralelismo en operaciones](#678)
- [**21.6** Paralelismo entre operaciones](#685)
- [**21.7** Diseño de sistemas paralelos](#687)
- [**21.8** Resumen](#688)
  - [Ejercicios](#689)
  - [Notas bibliográficas](#691)
### Capítulo 22 - Bases de datos distribuidas
- [**22.1** Bases de datos homogéneas y heterogéneas](#693)
- [**22.2** Almacenamiento distribuido de datos](#694)
- [**22.3** Transacciones distribuidas](#697)
- [**22.4** Protocolos de compromiso](#698)
- [**22.5** Control de la concurrencia en las bases de datos distribuidas](#704)
- [**22.6** Disponibilidad](#710)
- [**22.7** Procesamiento distribuido de consultas](#714)
- [**22.8** Bases de datos distribuidas heterogéneas](#717)
- [**22.9** Sistemas de directorio](#719)
- [**22.10** Resumen](#723)
  - [Ejercicios](#726)
  - [Notas bibliográficas](#728)
## Parte 8: Otros temas
### Capítulo 23 - Desarrollo avanzado de aplicaciones
- [**23.1** Ajuste del rendimiento](#733)
- [**23.2** Pruebas de rendimiento](#741)
- [**23.3** Normalización](#744)
- [**23.4** Migración de aplicaciones](#748)
- [**23.5** Resumen](#749)
  - [Ejercicios](#750)
  - [Notas bibliográficas](#751)
### Capítulo 24 - Tipos de datos avanzados y nuevas aplicaciones
- [**24.1** Motivación](#753)
- [**24.2** El tiempo en las bases de datos](#754)
- [**24.3** Datos espaciales y geográficos](#756)
- [**24.4** Bases de datos multimedia](#765)
- [**24.5** Computadoras portátiles y bases de datos personales](#767)
- [**24.6** Resumen](#772)
  - [Ejercicios](#773)
  - [Notas bibliográficas](#775)
### Capítulo 25 - Procesamiento avanzado de transacciones
- [**25.1** Monitores de procesamiento de transacciones](#777)
- [**25.2** Flujos de trabajo de transacciones](#781)
- [**25.3** Comercio electrónico](#786)
- [**25.4** Bases de datos en memoria principal](#788)
- [**25.5** Sistemas de transacciones de tiempo real](#790)
- [**25.6** Transacciones de larga duración](#791)
- [**25.7** Gestión de transacciones en varias bases de datos](#796)
- [**25.8** Resumen](#799)
  - [Ejercicios](#801)
  - [Notas bibliográficas](#802)
## Parte 9: Estudios de casos
### Capítulo 26 - PostgreSQL
> Anastassia Ailamaki, Sailesh Krishnamurthy, Spiros Papadimitriou, Bianca Schroeder
- [**26.1** Introducción](#807)
- [**26.2** Interfaces de usuario](#808)
- [**26.3** Variaciones y extensiones de SQL](#809)
- [**26.4** Gestión de transacciones en PostgreSQL](#817)
- [**26.5** Almacenamiento e índices](#824)
- [**26.6** Procesamiento y optimización de consultas](#827)
- [**26.7** Arquitectura del sistema](#830)
  - [Notas bibliográficas](#831)
### Capítulo 27 - Oracle
> Hakan Jakobsson
- [**27.1** Herramientas para el diseño de bases de datos y la consulta](#833)
- [**27.2** Variaciones y extensiones de SQL](#834)
- [**27.3** Almacenamiento e índices](#836)
- [**27.4** Procesamiento y optimización de consultas](#844)
- [**27.5** Control de concurrencia y recuperación](#849)
- [**27.6** Arquitectura del sistema](#851)
- [**27.7** Réplica, distribución y datos externos](#854)
- [**27.8** Herramientas de gestión de bases de datos](#855)
- [**27.9** Minería de datos](#856)
  - [Notas bibliográficas](#857)
### Capítulo 28 - DB2 Universal Database de IBM
> Sriram Padmanabhan
- [**28.1** Visión general](#859)
- [**28.2** Herramientas de diseño de bases de datos](#860)
- [**28.3** Variaciones y extensiones de SQL](#861)
- [**28.4** Almacenamiento e indexación](#864)
- [**28.5** Agrupación multidimensional](#867)
- [**28.6** Procesamiento y optimización de consultas](#870)
- [**28.7** Tablas de consultas materializadas](#874)
- [**28.8** Características autónomas de DB2](#876)
- [**28.9** Herramientas y utilidades](#876)
- [**28.10** Control de concurrencia y recuperación](#878)
- [**28.11** Arquitectura del sistema](#880)
- [**28.12** Réplicas, distribución y datos externos](#881)
- [**28.13** Características de inteligencia de negocio](#882)
  - [Notas bibliográficas](#882)
### Capítulo 29 - SQL Server de Microsoft
> Sameet Agarwal, José A. Blakeley, Thierry D’Hers, Gerald Hinson, Dirk Myers, Vaqar Pirzada, Bill Ramos, Balaji Rathakrishnan, Michael Rys, Florian Waas, Michael Zwilling
- [**29.1** Herramientas para la administración, el diseño y la consulta de las bases de datos](#885)
- [**29.2** Variaciones y extensiones de SQL](#889)
- [**29.3** Almacenamiento e índices](#892)
- [**29.4** Procesamiento y optimización de consultas](#895)
- [**29.5** Concurrencia y recuperación](#899)
- [**29.6** Arquitectura del sistema](#903)
- [**29.7** Acceso a los datos](#904)
- [**29.8** Procesamiento de consultas heterogéneas distribuidas](#905)
- [**29.9** Duplicación](#906)
- [**29.10** Programación de servidores en .NET](#908)
- [**29.11** Soporte de XML en SQL Server 2005](#912)
- [**29.12** Service Broker de SQLServer](#916)
- [**29.13** Almacenes de datos e inteligencia de negocio](#918)
  - [Notas bibliográficas](#921)
### Bibliografía
Capítulo 1 - **[⬆ vuelve al capítulo 1](#capítulo-1---introducción)**
## Introducción
**Un sistema gestor de bases de datos** (SGBD) es un conjunto de programas que permiten acceder a una colección de datos interrelacionados, comúnmente llamada **base de datos**, que contiene información relevante para una empresa. El propósito principal de un SGBD es almacenar y recuperar información de manera _eficiente_ y _práctica_.

Estos sistemas se diseñan para manejar grandes cantidades de información, definiendo estructuras de almacenamiento y mecanismos de manipulación de datos. Además, deben garantizar la seguridad y la integridad de los datos, especialmente cuando son compartidos entre usuarios.
### 1.1 Aplicaciones de los sistemas de bases de datos
Las bases de datos se usan ampliamente. Algunas de sus aplicaciones representativas son:
- _Banca:_ para la información de los clientes, cuentas, préstamos y transacciones bancarias.
- _Líneas aéreas:_ para reservas e información de horarios. Las líneas aéreas fueron de las primeras en
usar las bases de datos de forma distribuida geográficamente.
- _Universidades:_ para la información de los estudiantes, matrículas en las asignaturas y cursos.
- _Transacciones de tarjetas de crédito:_ para compras con tarjeta de crédito y la generación de los extractos mensuales.
- _Telecomunicaciones:_ para guardar un registro de las llamadas realizadas, generar las facturas mensuales, mantener el saldo de las tarjetas telefónicas de prepago y para almacenar información
sobre las redes de comunicaciones.
- _Finanzas:_ para almacenar información sobre compañías tenedoras, ventas y compras de productos financieros, como acciones y bonos; también para almacenar datos del mercado en tiempo real
para permitir a los clientes la compraventa en línea y a la compañía la compraventa automática.
- _Ventas:_ para información de clientes, productos y compras.
- _Comercio en línea:_ para los datos de ventas ya mencionados y para el seguimiento de los pedidos
Web, generación de listas de recomendaciones y mantenimiento de evaluaciones de productos
en línea.
- _Producción:_ para la gestión de la cadena de proveedores y para el seguimiento de la producción
de artículos en las factorías, inventarios en los almacenes y pedidos.
- _Recursos humanos:_ para información sobre los empleados, salarios, impuestos sobre los sueldos y
prestaciones sociales, y para la generación de las nóminas.

Las bases de datos son fundamentales en las empresas modernas, y su uso ha crecido en las últimas cuatro décadas. Inicialmente, poca gente interactuaba directamente con ellas, pero eso cambió con la llegada de cajeros automáticos y sistemas de respuesta vocal. La revolución de Internet permitió un acceso directo a las bases de datos a través de interfaces web. Actualmente, casi todas las personas interactúan con bases de datos sin darse cuenta, desde compras en línea hasta consultas bancarias. Empresas de software como Oracle son líderes en este campo, y las bases de datos son esenciales para empresas como Microsoft e IBM. En resumen, las bases de datos son esenciales en la vida cotidiana y en el mundo empresarial actual. _[⬆ vuelve al capítulo 1](#capítulo-1---introducción)_
### 1.2 Propósito de los sistemas de bases de datos
Los sistemas de bases de datos surgieron en respuesta a los primeros métodos de gestión informatizada de los datos comerciales. A modo de ejemplo de dichos métodos, típicos de los años sesenta, considérese parte de una entidad bancaria que, entre otros datos, guarda información sobre todos los clientes y todas las cuentas de ahorro. Una manera de guardar la información en la computadora es almacenarla en archivos del sistema operativo. Para permitir que los usuarios manipulen la información, el sistema tiene varios programas de aplicación que gestionan los archivos, incluyendo programas para:
- Efectuar cargos o abonos en las cuentas.
- Añadir cuentas nuevas.
- Calcular el saldo de las cuentas.
- Generar los extractos mensuales.

Los programadores los han escrito en respuesta a las necesidades del banco. Se añaden nuevos programas de aplicación al sistema según surgen las necesidades. Por ejemplo, supóngase que una caja de ahorros decide ofrecer cuentas corrientes. En consecuencia, se crean nuevos archivos permanentes que contienen información acerca de todas las cuentas corrientes abiertas en el banco y puede que haya que escribir nuevos programas de aplicación para afrontar situaciones que no se dan en las cuentas de ahorro, como los descubiertos. Así, con el paso del tiempo, se añaden más archivos y programas de aplicación al sistema.

Los sistemas operativos convencionales soportan este **sistema de procesamiento de archivos** típico. El sistema almacena los registros permanentes en varios archivos y necesita diferentes programas de aplicación para extraer y añadir a los archivos correspondientes. Antes de la aparición de los sistemas gestores de bases de datos (SGBDs), las organizaciones normalmente almacenaban la información en sistemas de este tipo.

Guardar la información de la organización en un sistema de procesamiento de archivos tiene una
serie de inconvenientes importantes:
- **Redundancia e inconsistencia de los datos:** Debido a que los archivos y programas de aplicación los crean diferentes programadores en el transcurso de un largo período de tiempo, es probable que los diversos archivos tengan estructuras diferentes y que los programas estén escritos en varios lenguajes de programación diferentes. Además, puede que la información esté duplicada en varios lugares (archivos). Por ejemplo, la dirección y el número de teléfono de un cliente dado pueden aparecer en un archivo que contenga registros de cuentas de ahorros y en un archivo que contenga registros de cuentas corrientes. Esta redundancia conduce a costes de almacenamiento y de acceso más elevados. Además, puede dar lugar a la inconsistencia de los datos; es decir, puede que las diferentes copias de los mismos datos no coincidan. Por ejemplo, puede que el cambio en la dirección de un cliente esté reflejado en los registros de las cuentas de ahorro pero no en el resto del sistema.
- **Dificultad en el acceso a los datos:** Supóngase que uno de los empleados del banco necesita averiguar los nombres de todos los clientes que viven en un código postal dado. El empleado pide al departamento de procesamiento de datos que genere esa lista. Debido a que esta petición no fue prevista por los diseñadores del sistema original, no hay un programa de aplicación a mano para satisfacerla. Hay, sin embargo, un programa de aplicación que genera la lista de todos los clientes. El empleado del banco tiene ahora dos opciones: bien obtener la lista de todos los clientes y extraer manualmente la información que necesita, o bien pedir a un programador de sistemas que escriba el programa de aplicación necesario. Ambas alternativas son obviamente insatisfactorias. Supóngase que se escribe el programa y que, varios días más tarde, el mismo empleado necesita reducir esa lista para que incluya únicamente a aquellos clientes que tengan una cuenta con saldo igual o superior a 10.000 e. Como se puede esperar, no existe ningún programa que genere tal lista. De nuevo, el empleado tiene que elegir entre dos opciones, ninguna de las cuales es satisfactoria.
La cuestión aquí es que los entornos de procesamiento de archivos convencionales no permiten recuperar los datos necesarios de una forma práctica y eficiente. Hacen falta sistemas de recuperación de datos más adecuados para el uso general.
- **Aislamiento de datos:** Como los datos están dispersos en varios archivos, y los archivos pueden estar en diferentes formatos, es difícil escribir nuevos programas de aplicación para recuperar los datos correspondientes.
- **Problemas de integridad:** Los valores de los datos almacenados en la base de datos deben satisfacer ciertos tipos de restricciones de consistencia. Por ejemplo, el saldo de ciertos tipos de cuentas bancarias no puede nunca ser inferior a una cantidad predeterminada (por ejemplo, 25 e). Los desarrolladores hacen cumplir esas restricciones en el sistema añadiendo el código correspondiente en los diversos programas de aplicación. Sin embargo, cuando se añaden nuevas restricciones, es difícil cambiar los programas para hacer que se cumplan. El problema se complica cuando las restricciones implican diferentes elementos de datos de diferentes archivos.
- **Problemas de atomicidad:** Los sistemas informáticos, como cualquier otro dispositivo mecánico o eléctrico, está sujeto a fallos. En muchas aplicaciones es crucial asegurar que, si se produce algún fallo, los datos se restauren al estado consistente que existía antes del fallo. Considérese un programa para transferir 50 e desde la cuenta A a la B. Si se produce un fallo del sistema durante la ejecución del programa, es posible que los 50 e fueran retirados de la cuenta A pero no abonados en la cuenta B, dando lugar a un estado inconsistente de la base de datos. Evidentemente, resulta esencial para la consistencia de la base de datos que tengan lugar tanto el abono como el cargo, o que no tenga lugar ninguno. Es decir, la transferencia de fondos debe ser atómica—debe ocurrir en su totalidad o no ocurrir en absoluto. Resulta difícil asegurar la atomicidad en los sistemas convencionales de procesamiento de archivos.
- **Anomalías en el acceso concurrente:** Para aumentar el rendimiento global del sistema y obtener una respuesta más rápida, muchos sistemas permiten que varios usuarios actualicen los datos simultáneamente. En realidad, hoy en día, los principales sitios de comercio electrónico de Internet pueden tener millones de accesos diarios de compradores a sus datos. En tales entornos es posible la interacción de actualizaciones concurrentes y puede dar lugar a datos inconsistentes. Considérese una cuenta bancaria A, que contenga 500 e. Si dos clientes retiran fondos (por ejemplo, 50 e y 100 e, respectivamente) de la cuenta A aproximadamente al mismo tiempo, el resultado de las ejecuciones concurrentes puede dejar la cuenta en un estado incorrecto (o inconsistente). Supóngase que los programas que se ejecutan para cada retirada leen el saldo anterior, reducen su valor en el importe que se retira y luego escriben el resultado. Si los dos programas se ejecutan concurrentemente, pueden leer el valor 500 e, y escribir después 450 e y 400 e, respectivamente. Dependiendo de cuál escriba el valor en último lugar, la cuenta puede contener 450 e o 400 e, en lugar del valor correcto, 350 e. Para protegerse contra esta posibilidad, el sistema debe mantener alguna forma de supervisión. Pero es difícil ofrecer supervisión, ya que muchos programas de aplicación diferentes que no se han coordinado con anterioridad pueden tener acceso a los datos.
- **Problemas de seguridad:** No todos los usuarios de un sistema de bases de datos deben poder acceder a todos los datos. Por ejemplo, en un sistema bancario, el personal de nóminas sólo necesita ver la parte de la base de datos que contiene información acerca de los diferentes empleados del banco. No necesitan tener acceso a la información acerca de las cuentas de clientes. Pero, como los programas de aplicación se añaden al sistema de procesamiento de datos de una forma adhoc, es difícil hacer cumplir tales restricciones de seguridad.

Estas dificultades, entre otras, motivaron el desarrollo de los sistemas de bases de datos. En el resto del libro se examinarán los conceptos y los algoritmos que permiten que los sistemas de bases de datos resuelvan los problemas de los sistemas de procesamiento de archivos. En general, en este libro se usa una entidad bancaria como ejemplo de aplicación típica de procesamiento de datos que puede encontrarse en una empresa. _[⬆ vuelve al capítulo 1](#capítulo-1---introducción)_

### Visión de los datos
**[⬆ vuelve al principio](#fundamentos-de-bases-de-datos)**